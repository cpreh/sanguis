// Generated by CoffeeScript 1.7.1
(function() {
  var AALine, Dim, Pos, Rand, Rect, draw_rect, draw_rects, generate_rects, init, inside, intersect, randn, random_int, rng, seed, shuffle;

  Rand = (function() {
    function Rand(seed) {
      this.seed = seed;
      this.multiplier = 1664525;
      this.modulo = 4294967296;
      this.offset = 1013904223;
      if (!((this.seed != null) && (0 <= seed && seed < this.modulo))) {
        this.seed = (new Date().valueOf() * new Date().getMilliseconds()) % this.modulo;
      }
    }

    Rand.prototype.seed = function(seed) {
      return this.seed = seed;
    };

    Rand.prototype.randn = function() {
      return this.seed = (this.multiplier * this.seed + this.offset) % this.modulo;
    };

    Rand.prototype.randf = function() {
      return this.randn() / this.modulo;
    };

    Rand.prototype.rand = function(n) {
      return Math.floor(this.randf() * n);
    };

    Rand.prototype.rand2 = function(min, max) {
      return min + this.rand(max - min);
    };

    return Rand;

  })();

  Pos = (function() {
    function Pos(x, y) {
      this.x = x;
      this.y = y;
    }

    Pos.prototype.plus = function(dim) {
      return new Pos(this.x + dim.w, this.y + dim.h);
    };

    return Pos;

  })();

  Dim = (function() {
    function Dim(w, h) {
      this.w = w;
      this.h = h;
    }

    return Dim;

  })();

  AALine = (function() {
    function AALine(p1, p2) {
      var _ref, _ref1;
      this.p1 = p1;
      this.p2 = p2;
      if (this.p1.x === this.p2.x) {
        if (this.p2.y < this.p1.y) {
          _ref = [this.p2, this.p1], this.p1 = _ref[0], this.p2 = _ref[1];
          return;
        }
      }
      if (this.p1.y === this.p2.y) {
        if (this.p2.x < this.p1.x) {
          _ref1 = [this.p2, this.p1], this.p1 = _ref1[0], this.p2 = _ref1[1];
          return;
        }
      }
    }

    return AALine;

  })();

  Rect = (function() {
    function Rect(pos, dim) {
      this.pos = pos;
      this.dim = dim;
      this.neighbor = void 0;
    }

    Rect.prototype.clip = function(other) {
      var bottom, left, oldx, oldy, right, top;
      if (inside(other.pos, this) && inside(other.pos.plus(other.dim), this)) {
        this.dim.w = other.pos.x - this.pos.x - 1;
        this.neighbor = other;
      }
      top = new AALine(this.pos, new Pos(this.pos.x + this.dim.w, this.pos.y));
      if (intersect(top, other)) {
        oldy = this.pos.y;
        this.pos.y = other.pos.y + other.dim.h + 1;
        this.dim.h -= this.pos.y - oldy;
        this.neighbor = other;
      }
      right = new AALine(new Pos(this.pos.x + this.dim.w, this.pos.y), new Pos(this.pos.x + this.dim.w, this.pos.y + this.dim.h));
      if (intersect(right, other)) {
        this.dim.w = other.pos.x - 1 - this.pos.x;
        this.neighbor = other;
      }
      bottom = new AALine(new Pos(this.pos.x + this.dim.w, this.pos.y + this.dim.h), new Pos(this.pos.x, this.pos.y + this.dim.h));
      if (intersect(bottom, other)) {
        this.dim.h = other.pos.y - 1 - this.pos.y;
        this.neighbor = other;
      }
      left = new AALine(new Pos(this.pos.x, this.pos.y + this.dim.h), this.pos);
      if (intersect(left, other)) {
        oldx = this.pos.x;
        this.pos.x = other.pos.x + other.dim.w + 1;
        this.dim.w -= this.pos.x - oldx;
        return this.neighbor = other;
      }
    };

    return Rect;

  })();

  inside = function(point, rect) {
    return point.x >= rect.pos.x && point.x <= rect.pos.x + rect.dim.w && point.y >= rect.pos.y && point.y <= rect.pos.y + rect.dim.h;
  };

  intersect = function(line, rect) {
    return line.p2.x >= rect.pos.x && line.p1.x <= rect.pos.x + rect.dim.w && line.p1.y <= rect.pos.y + rect.dim.h && line.p2.y >= rect.pos.y;
  };

  seed = 2109415156;

  console.log("seed: " + seed);

  rng = new Rand(seed);

  randn = function() {
    return rng.randn();
  };

  random_int = function(a, b) {
    return a + randn() % (b - a + 1);
  };

  shuffle = function(a) {
    var i, j, _i, _ref, _ref1;
    for (i = _i = _ref = a.length - 1; _ref <= 1 ? _i <= 1 : _i >= 1; i = _ref <= 1 ? ++_i : --_i) {
      j = random_int(0, i);
      _ref1 = [a[j], a[i]], a[i] = _ref1[0], a[j] = _ref1[1];
    }
    return a;
  };

  generate_rects = function(ctx, width, height) {
    var h, i, other, rect, rects, w, wellformed, x, y, _i, _j, _len;
    rects = [];
    for (i = _i = 1; _i <= 100; i = ++_i) {
      x = random_int(0, 100);
      y = random_int(0, 75);
      w = Math.min(random_int(10, 40), 100 - x);
      h = Math.min(random_int(10, 40), 75 - y);
      rect = new Rect(new Pos(x, y), new Dim(w, h));
      wellformed = true;
      for (_j = 0, _len = rects.length; _j < _len; _j++) {
        other = rects[_j];
        rect.clip(other);
        wellformed = rect.dim.w > 2 && rect.dim.h > 2;
        if (!wellformed) {
          break;
        }
      }
      if (wellformed) {
        rects.push(rect);
      }
    }
    return rects;
  };

  draw_rect = function(ctx, tilesize, rect, color) {
    ctx.fillStyle = color != null ? color : "#883";
    ctx.fillRect(tilesize * rect.pos.x, tilesize * rect.pos.y, tilesize * rect.dim.w, tilesize * rect.dim.h);
    if (rect.dim.w === 1 || rect.dim.h === 1) {
      return;
    }
    ctx.fillStyle = "#000";
    return ctx.fillRect(tilesize * (rect.pos.x + 1), tilesize * (rect.pos.y + 1), tilesize * (rect.dim.w - 2), tilesize * (rect.dim.h - 2));
  };

  draw_rects = function(ctx, tilesize, width, height, rects) {
    var canvas, gridsize, random_color, rect, set_tile, _i, _len, _results;
    canvas = ctx.canvas;
    gridsize = new Dim(canvas.width / tilesize, canvas.height / tilesize);
    console.log("grid: " + gridsize.w + " x " + gridsize.h);
    ctx.fillStyle = "#aaa";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    set_tile = function(x, y, color) {
      ctx.fillStyle = color != null ? color : "#883";
      return ctx.fillRect(tilesize * x, tilesize * y, tilesize, tilesize);
    };
    random_color = function() {
      var r;
      r = [random_int(0, 255), 255, 0];
      shuffle(r);
      return "rgb(" + r[0] + "," + r[1] + "," + r[2] + ")";
    };
    _results = [];
    for (_i = 0, _len = rects.length; _i < _len; _i++) {
      rect = rects[_i];
      _results.push(draw_rect(ctx, tilesize, rect, '#883'));
    }
    return _results;
  };

  init = function() {
    var canvas, ctx, highlight_rect, mouse_pos, rects, tilesize;
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    rects = generate_rects();
    tilesize = 4;
    draw_rects(ctx, tilesize, 800, 600, rects);
    mouse_pos = function(event) {
      var rect;
      rect = canvas.getBoundingClientRect();
      return new Pos(Math.floor((event.clientX - rect.left) / tilesize), Math.floor((event.clientY - rect.top) / tilesize));
    };
    highlight_rect = function(event) {
      var rect, _i, _len, _results;
      console.log(mouse_pos(event));
      draw_rects(ctx, tilesize, 800, 600, rects);
      _results = [];
      for (_i = 0, _len = rects.length; _i < _len; _i++) {
        rect = rects[_i];
        if (inside(mouse_pos(event), rect)) {
          draw_rect(ctx, tilesize, rect, '#f00');
          _results.push(draw_rect(ctx, tilesize, rect.neighbor, '#0f0'));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    return canvas.addEventListener('click', highlight_rect);
  };

  window.addEventListener('load', init);

}).call(this);
